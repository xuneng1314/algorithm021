Week01 学习总结
在学习过程中，遇到最大的问题就是栈、队列、双端队列的使用场景问题
基础的逻辑比较好理解，栈是一个后进先出的数据结构，队列是一个先进先出的数据结构，双端队列只能在队列的任意一端入队和出队，
栈的使用场景：
1.网络浏览器的后退功能:每次浏览一个网页，入栈，浏览新的网站，就把新的网站压入到栈顶，这样如果做后退功能只需要pop栈顶元素，如果需要实现前进功能，那就使用另外一个栈缓存后退之后pop出来的网站即可
2.文本编辑器的撤销功能：每次文本的变化都push入栈，使用撤销功能时只要pop出上一次的操作，就能还原上一次输入的内容
3.判断括号是否有效：每次压入栈，当遇到挨着的有效闭合的括号之后，分别把他们pop出栈，直到栈为空，否则不是有效的括号
栈使用的接口大致分为：
push(e),将一个元素e压入到栈顶
pop(),弹出栈顶元素
top(),返回栈顶元素，不做操作
isempty(),判断一个栈是否为空
size()，返回栈的个数
栈的实现有两种，基于数组，基于链表
数组的实现：只需要记录栈顶的指针，每次入栈出栈只需要操作栈顶指针即可，（如果栈空间满了，需要重新申请一块内存，然后将元素复制过去，默认栈空间个数为10）
链表的实现：使用单向链表实现，每个不要他的next指针，只需要记录pre指针，即指向我前一个节点的指针，需要存储栈顶元素，top始终返回最新的节点，如果pop一个数据，则top指向弹出节点的pre节点即可

栈的使用难点在于，一个算法题如何分析使用栈会更容易求解，例如"柱状图中最大的矩形"这个问题，可以使用栈的方式来实现，但是一拿到题目不知道可以使用栈来实现，那么有什么规律可以让我们看到题目就能考虑使用栈的方式来解决呢？

优先队列实际实现原理运用到了数据结构-堆，例如优先级高的先出队，可以建立一个大根堆，根节点是优先级最高的，出队把根节点出队，然后重新构建堆即可。
时间复杂度分析
普通队列：入队时间复杂度是O(1),获取最大元素时间复杂度是O(n)
优先队列：入队和出队时间复杂度都是O(logn)，因为使用到了堆这种数据结构，每次入队和出队都需要重新构建堆，堆是一个完全二叉树

如何找到队列中的最大值：使用优先队列实现，可以在O(logn)的时间复杂度找到，

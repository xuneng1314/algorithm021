第二周学习总结
本周学习了哈希表、树、图等数据结构
哈希表在平常的工作中是使用的特别多的一种，主要是为了更快的定位数据是否存在，时间复杂度为O(1)
哈希表在各个语言中都有对应的实现，python的dict，java的hashmap，c++的unordered_map，lua的table。
hashmap具体底层实现：hashmap主要存储是已数组的形式存储，一个key通过hash函数对应到数组的一个位置，不过由于不同的key通过hash函数得到的值可能是相同的，所以会通过一个链表存储冲突的节点，极端情况下hashmap时间复杂度会退化成O(n),所以jdk8.0以后就优化了hashmap的拉链法的实现，当节点个数超过5个以上，就把链表转换成红黑树，优化成log(n)的时间复杂度。
hashmap为了解决哈希冲突的几率，也制定了一定的扩容规则，当hashmap的装载因子超过了一定的值时，默认装载因子是0.75，即数组长度是100的话，元素个数超过了75个，就会数组扩容，默认扩容成2倍大小。扩容之后需要做数据的rehash，java是全量rehash的，有一些开源框架的rehash是用的渐进式rehash，即在定时器和hashmap的访问过程中rehash一部分数据，例如redis的dict。

树的运用比较多的是二叉搜索树，能够在log(n)时间复杂度中找到所需要的数据，二叉搜索树的中序遍历的结果就是一个排序好的数组。
堆这种数据结构是一个可以在爱O(1)时间复杂度拿到最大值或者最小值的，分为大根堆和小根堆。这也是对排序的实现方法。
堆排序：
以从小到大排序，实现思路就是把数组建立成一个小根堆，这样拿到堆顶的第一个元素，即为最小的值
取出最小值之后需要重新建立小根堆，经过n次建堆过程，就完成了排序的。由于建堆的时间复杂度是log(n)需要建立n次堆、所以堆排序的时间复杂度是nlog(n)。不过对排序的运用是比较少的。因为有更好的归并排序和快速排序。如果数组基本有序的话，堆排序还是会每次都把数组顺序打乱
堆的使用主要是用在优先队列的实现上，计算机系统的作业调度就是基于最大优先级队列实现，每次拿到优先级最高的任务执行。

